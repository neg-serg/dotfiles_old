:q
:q
:q
X
:q
:
X
X
:q
do x <- [2,3,4]; return (x*2) 
do x <- [2,3,4]; return (x*2) 
do x <- [2,3,4]; y <- [3,4,5,6]; return (x*y) 
do x <- [2,3,4]; y <- [3,4,5,6]; return (x*y) 
:q
:reload 
:q
:q
:q
:q
:
:q
headDubl [3,4,5,1]
let headDubl l@(x:xs)=x:l
:q
let ack 0,n =n+1
ack 0 =n+1
ack 0,n =n+1
let fact (n+1) = (n+1)*fact n
let fact (n+1) = (n+1)*fact n
let fact (n+1) = fact n *(n+1)
let fact 1=1
let fact 0=1
last []
:q
:q
:q
:q
:q
:q
1+2
1+2
5>7
not True
'c'
3
c
'3'
:q
map (+1) [1..5]
:q
Жй
:m +Control.Monad.Stream
:q
let squares            =  array (1,100) [(i, i*i) | i <- [1..100]]
spsum [3,4,5,6,1] [4,5,6,2,1,3]
:reload 
repl q w "jwekfjkffffff24f42f2424fwwwwwwwwwwqqqqqqq"
repl q, w, "jwekfjkffffff24f42f2424fwwwwwwwwwwqqqqqqq"
repl q,w,"jwekfjkffffff24f42f2424fwwwwwwwwwwqqqqqqq"
repl [q,w,"jwekfjkffffff24f42f2424fwwwwwwwwwwqqqqqqq"]
:q
:e
let repl :: Char -> Char -> String -> String
repl :: Char -> Char -> String -> String
let repl :: Char -> Char -> String -> String
let getPositive = filter (\h -> h /= p 0)
getPositive [1,2,-3,-4,5,-5]
getPositive [1,2,3,4,5,-5]
let getPositive = filter (\x -> x > 0)
:q
/tmp
:reload 
:reload 
removeEmpty2 ["weqqewqw","","qewqew"]
removeEmpty ["weqqewqw","","qewqew"]
removeEmpty3 ["weqqewqw","","qewqew"]
:q
print sum (4 4)
print sum 4 4
print sum 4
sum
sum 4 5
sum
perfects
let perfects = [x|x<-[2..256], sum ([y|y<-[1..x],mod x y == 0]) == x ]
perfects
let perfects = [x|x<-[1..256], sum ([y|y<-[1..x],mod x y == 0]) == x ]
let perfects = [x|x<-[1..256], sum ([y|y<-[1..x],mod x y == 0]) == x ]
perfects
let perfects = [x|x<-[2..256], sum ([y|y<-[1..x],mod x y == 0]) == x ]
perfects
let perfects = [x|x<-[1..256], sum ([y|y<-[1..x],mod x y == 0]) == x ]
perfects
let perfects = [x|x<-[1..128], sum ([y|y<-[1..x],mod x y == 0]) == x ]
perfects
let perfects = [x|x<-[1..1000000], sum ([y|y<-[1..x],mod x y == 0]) == x ]
perfects
let perfects = [x|x<-[1..], sum ([y|y<-[1..x],mod x y == 0]) == x ]
perfects
let perfects = [x|x<-[2..], sum ([y|y<-[1..x],mod x y == 0]) == x ]
