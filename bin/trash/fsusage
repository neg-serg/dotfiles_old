#!/bin/bash
#
# Copyright 2004,2009 Aron Griffis <agriffis@n01se net>
# Released under the GNU GPL v3
#
# fsusage: check filesystem usage and issue a warning if necessary
# 

PATH=/usr/bin:/bin:/usr/sbin:/sbin

main() {
    declare opt_all=false
    declare opt_state=rw
    declare opt_statedir=$HOME/.fsusage
    declare opt_red=98
    declare opt_yellow=90
    declare opt_syslog=false
    declare shortopts=( a:all r:red y:yellow )
    declare -a parsed_opts parsed_params
    parse_cmdline "$@" || exit
    set -- "${parsed_params[@]}"

    if $opt_syslog; then
        if ! type -P logger &>/dev/null; then
            die "logger required for --syslog"
        else
            exec > >(logger -p local0.alert -t fsusage)
        fi
    fi

    declare rs ws
    [[ $opt_state == *r* ]] && rs=true || rs=false
    [[ $opt_state == *w* ]] && ws=true || ws=false
    $opt_all && rs=false
    $ws && { mkdir -p "$opt_statedir" || die; }

    check "$@"
}

opt_help() {
    cat <<EOT
usage: fsusage [options] [filesystems]

    -a  --all           Show all filesystems including GREEN
    -r  --red PCT       Percentage to warn RED ($opt_red)
    -y  --yellow PCT    Percentage to warn YELLOW ($opt_yellow)
        --state RW      RW=r to read state files,
                        RW=w to write state files,
                        RW=rw for both, RW="" for neither
        --statedir DIR  State directory ($opt_statedir)
        --syslog        Output to syslog instead of stdout
EOT
}

die() {
    [[ -n $* ]] && echo "${0##*/}: $*" >&2
    exit 1
}

# utility, depends on vars declared in check()
report() {
    case $1 in
        GREEN)
            echo "info: $mnt is $1 at $pct% ($used of $total used)"
            $ws && rm -f "$statefile" ;;
        *)
            echo "warning: $mnt is $1 at $pct% ($used of $total used)"
            $ws && echo $pct > "$statefile" ;;
    esac
}

check() {
    declare fs total used foo pct mnt statefile t

    if [[ $# -ne 0 ]]; then
        df -hP "$@" | tail -n +2
    else
        df -lhPx iso9660 | grep '^/' # local filesystems only
    fi | \
    while read fs total used foo pct mnt foo; do
        pct=${pct%\%}
        statefile=$opt_statedir/usage${fs//\//_}

        if [[ $pct -ge $opt_red ]]; then
            report RED

        elif [[ $pct -ge $opt_yellow ]]; then
            if [[ $rs == false || ! -r $statefile ]]; then
                report YELLOW
            elif [[ $pct -gt $(<$statefile) ]]; then
                report YELLOW
            else
                t=$(mktemp)
                touch -d '1 day ago' "$t"
                if [[ $statefile -ot $t ]]; then
                    report YELLOW
                fi
                rm -f "$t"
            fi

        else
            if $opt_all; then
                report GREEN
            elif [[ $rs == true && -r $statefile && \
                    $(<$statefile) -ge $opt_yellow ]]; then
                report GREEN
            fi
        fi
    done
}

#=============================================================================
# simple bash command-line processing
#
# (c) Copyright 2008 Aron Griffis <agriffis@n01se.net>
# Released under the GNU GPL v3
#=============================================================================

parse_cmdline() {
    # extract long options from variable declarations
    declare getopt_long=$(set | \
        sed '/^opt_/!d; s/^opt_//; s/_/-/g;
            s/\(.*\)=false$/\1 no-\1/;
            s/\(.*\)=true$/\1 no-\1/;
            s/=.*/:/; s/()//;' | xargs | sed 's/ /,/g')

    # augment the shortopts array with takes-a-value colon;
    # for example f:file becomes f::file
    declare shortopts=( "${shortopts[@]}" )
    declare i x
    for ((i=0; i<${#shortopts[@]}; i++)); do
        x=${shortopts[i]}
        if [[ ",$getopt_long," == *,"${x#?:}":,* ]]; then
            shortopts[i]=${x/:/::}
        fi
    done
    declare getopt_short=$(IFS=''; echo "${shortopts[*]%:*}")

    declare args
    args=$(getopt -o "$getopt_short" \
        --long "$getopt_long" -n "$0" -- "$@") || return
    eval set -- "$args"

    declare opt var val
    parsed_opts=()
    while true; do
        [[ $1 == -- ]] && { shift; break; }

        # translate short options to long
        if [[ $1 == -? ]]; then
            opt=${1#-}
            for x in "${shortopts[@]}"; do
                if [[ $x == "$opt":* ]]; then
                    opt=${x##*:}
                    break
                fi
            done
        else
            opt=${1#--}
        fi

        # figure out $var and $val; shift positional params
        var=opt_${opt//-/_}
        case ",$getopt_long," in
            # make sure to handle opt_no_something (--no-something) 
            # which has a (silly) negation of --no-no-something
            *",no-$opt,"*)
                val=true
                parsed_opts=( "${parsed_opts[@]}" "$1" )
                shift ;;
            *",$opt,"*)
                if [[ $opt == no-* ]]; then
                    var=${var/no_/}
                    val=false
                else
                    val=true
                fi
                parsed_opts=( "${parsed_opts[@]}" "$1" )
                shift ;;
            *",$opt:,"*) 
                val=$2
                parsed_opts=( "${parsed_opts[@]}" "$1" "$2" )
                shift 2 ;;
            *)
                echo "error processing $1: not in getopt_long?" >&2
                return 1 ;;
        esac

        if [[ $(type -t "$var") == function ]]; then
            $var $val # val is true/false
        elif [[ $(type -t "$var:") == function ]]; then
            $var: "$val"
        elif is_array "$var"; then
            eval "$var=( \"\${$var[@]}\" $(printf %q "$val") )"
        elif is_var "$var"; then
            eval "$var=\$val"
        else
            echo "error processing $var: no func/array/var?" >&2
            return 1
        fi
    done

    parsed_params=( "$@" )
}

getopt() {
    declare cmd=${cmd:-${0##*/}}
    if [[ $(command getopt --help 2>&1) == *--longoptions* ]]; then
        command getopt "$@"
    elif [[ $OSTYPE == darwin* ]]; then
        if [[ ! -x /opt/local/bin/getopt ]]; then
            echo "Error: $cmd requires GNU getopt" >&2
            echo "Please install from http://getopt.darwinports.com/" >&2
            exit 1
        fi
        /opt/local/bin/getopt "$@"
    else
        echo "Error: $cmd requires GNU getopt" >&2
        exit 1
    fi
}

is_var() {
    declare -p "$1" &>/dev/null
}

is_array() {
    set -- $(declare -p "$1" 2>/dev/null)
    [[ $2 == -*a* ]]
}

main "$@"
