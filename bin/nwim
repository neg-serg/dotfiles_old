#!/usr/bin/env python3

""" nwim runner

Usage:
  nwim.py

Options:
  -h --help     Show this screen.
  --version     Show version.

Created by :: Neg
email :: <serg.zorg@gmail.com>
github :: https://github.com/neg-serg?tab=repositories
year :: 2017

"""

# --[ scripts interaction ]-------
from psutil import net_connections
import subprocess
import time
import os.path
import socket

import re

# --[ shell interaction ]---------
import shlex
from pathlib import Path

# --[ options ]-------------------
from sys import argv
import docopt

# --[ colors ]--------------------
from colored import fg, bg, attr

# --[ interact with redis ]-------
import redis

class wim_runner(object):
    def __init__(self):
        self.settings={
            "use_neovim":True,
            "debug":False,
        }

        self.font="PragmataPro for Powerline"
        self.fsize=22

        self.sock_path=os.path.realpath(os.path.expandvars("$HOME/1st_level/nvim.socket"))
        os.environ["NVIM_LISTEN_ADDRESS"]=self.sock_path
        self.tmux_sock_path=os.path.realpath(os.path.expandvars("$HOME/1st_level/tmux_nvim.socket"))
        self.socket_ = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)

        self.vim_commands={
            "to_normal": "<C-\><C-N>:call<SPACE>foreground()<CR>",
            "state_before": "",
            "state_after": "",
        }

        self.timeout=0.1

        self.r=redis.StrictRedis(host='localhost', port=6379, db=0)
        self.cmd_=""

        if self.settings["use_neovim"]:
            self.wim_name="nwim"
        else:
            self.wim_name="wim"

    def dprint(self, debug_string):
        if self.settings["debug"]:
            print(debug_string)

    def dprint_with_args(self, debug_string, args):
        def print_args(args):
            self.dprint("[::] Printing args [::]")
            for arg in args:
                self.dprint("{ "+ arg +" }")

        self.dprint("[ " + debug_string + " ]")
        print_args(args)

    # --[ print x11 windows hierarchy ]--
    def print_windows(self, window, indent):
        wins = window.query_tree().children
        for win in wins:
            self.dprint(indent, window.get_wm_class())
            print_windows(win, indent+'-')

    # --[ goto neovim window ]--
    def wim_goto(self):
        def there_is(wm_):
            pipe = subprocess.Popen('pidof {}'.format(wm_).split(), stdout=subprocess.PIPE)
            pid, _ = pipe.communicate()
            return pid != b''

        if there_is("notion"):
            self.dprint("[notion] :: go to win with it")
            subprocess.Popen(["notionflux", "-e", "app.byclass('', '{}')".format(self.wim_name)], stdout=subprocess.PIPE)
        elif there_is("i3"):
            self.dprint("[i3] :: go to win with it")
            subprocess.Popen(["i3-msg", '[instance={}]'.format(self.wim_name), "focus"], stdout=subprocess.PIPE)

    # --[ it is the main function in the past, not sure for now ]--------
    def V(self, args):
        # --[ maybe I should add some auto-quoting here, not sure yet ]--
        self.dprint_with_args("Run V", args)
        del args[0]
        self.wim_run(args, "default")
        self.wim_goto()

    # --[ Open file in daemon and print nice file info ]----------------------
    # --[ Main function with several closures ]-------------------------------
    def vim_file_open(self, line):
        def remote_send():
            # --[ helper for remote_send ]---------------------------------[1]
            def remote_edit_file():
                self.dprint("[remote edit file]")
                ret=remote_edit_pipe = subprocess.Popen(
                    shlex.split(
                        "nvr --remote-send " + \
                        "\"" + \
                        self.vim_commands["to_normal"] + \
                        ":silent edit " + \
                        file_name_ + \
                        "<CR>" + \
                        self.cmd_ + \
                        "\""
                    ),
                    stdout=subprocess.PIPE,
                    stderr=subprocess.STDOUT
                ).communicate()[0].decode("utf-8").strip('\n')

            # --[ helper for remote_send ]---------------------------------[2]
            # --[ check wim started or not by internal variable in nvim ]--[2]
            def wim_is_started():
                self.dprint("[check for start]")
                ret=remote_expr_pipe = subprocess.Popen(
                    shlex.split(""" nvr --remote-expr "printf(\"%s\", g:nvim_is_started)" """),
                    stdout=subprocess.PIPE,
                    stderr=subprocess.STDOUT
                ).communicate()[0].decode("utf-8").strip('\n')
                if ret == "on":
                    return True
                else:
                    return False

            self.dprint("[remote send]")
            remote_send_pipe = subprocess.Popen(
                shlex.split(
                            "nvr --remote-send " + \
                            "\"" + \
                            self.vim_commands["to_normal"] + \
                            ":silent edit " + \
                            file_name_ + \
                            "<CR>" + \
                            self.cmd_ + \
                            "\""
                            ),
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT
            )
            remote_send_result=remote_send_pipe.communicate()[0]
            if remote_send_pipe.returncode != 0:
                while not wim_is_started():
                    time.sleep(self.timeout)
                remote_edit_file()

        file_name_=os.path.realpath(line)

        # --[ counting with external wc is faster than everything else ]--
        def wccount_(filename):
            out = subprocess.Popen(
                ['wc', '-l', filename],
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT
            ).communicate()[0]

            return int(out.partition(b' ')[0])

        # --[ generic string wrapper ]---------------------------------
        def wrap_string_(str):
            return fg(4) + "[" + fg(7) + str + fg(4) + "]"

        def size_msg_wrap_(file_size):
            return wrap_string_(fg(7) + "sz" + fg(237) + "~" + fg(7) + str(file_size))

        def len_msg_wrap_(len):
            return wrap_string_(fg(7) + "len" + fg(237) + "=" + fg(7) + str(len))

        def new_file_msg_wrap_(new_filename):
            return wrap_string_(new_filename)

        def dir_msg_wrap_(filename):
            return wrap_string_(filename)

        def print_prefix_():
            return wrap_string_(">>")

        def delimiter_():
            return (fg(200) + " :: " + fg(0))

        # --[ pretty printing for filename ]---------------------------
        def fancy_name_(filename):
            filename=re.sub(os.environ["HOME"], fg(2) + "~" + fg(7), filename)
            filename=re.sub("/", fg(4) + "/" + fg(7), filename)
            return wrap_string_(filename)

        # --[ normalize path ]-----------------------------------------
        file_name_=os.path.normpath(file_name_)

        file_stats_=os.stat(file_name_)
        file_size_=file_stats_.st_size
        file_length_=wccount_(file_name_)
        file_=Path(file_name_)

        # Open target file
        remote_send()

        if not file_.exists():
            print(
                print_prefix_() + \
                fancy_name_(file_name_) + \
                delimiter_() + \
                new_file_msg_wrap_(file_name_)
            )
        elif file_.is_file() and not file_.is_dir():
            print(
                print_prefix_() + \
                fancy_name_(file_name_) + \
                delimiter_() + \
                size_msg_wrap_(file_size_) + \
                delimiter_() + \
                len_msg_wrap_(file_length_)
            )
        elif file_.is_dir():
            if file_name_ == os.getcwd():
                print(
                    print_prefix_() + \
                    wrap_string_("current dir") + \
                    delimiter_() + \
                    dir_msg_wrap_(file_name_)
                )
            else:
                print(
                    print_prefix_() + \
                    fancy_name_(file_name_) + \
                    delimiter_() + \
                    dir_msg_wrap_(file_name_)
                )

    def process_list(self, args, timer=.05):
        # self.wim_goto()
        time.sleep(timer)

        self.cmd_=self.vim_commands["to_normal"] + \
            self.vim_commands["state_before"] + \
            self.vim_commands["state_after"]

        if self.cmd_ == self.vim_commands["to_normal"]:
            for line in args:
                self.vim_file_open(line)
        else:
            wim=subprocess.Popen(
                shlex.split("nvr --remote-send " + self.cmd_),
                stdout=subprocess.PIPE
            )

            for line in args:
                self.vim_file_open(line)

        self.vim_commands["state_after"]=""
        self.vim_commands["state_before"]=""

    def eprocess_list(self, args, timer=.05):
        self.wim_goto()
        time.sleep(timer)
        for line in args:
            self.dprint(line)
            wim=subprocess.Popen(
                shlex.split("nvr --remote-wait "+' '.join(map(str, args))),
                stdout=subprocess.PIPE
            )

    def create_wim_server_from_scratch(self):
        wim=subprocess.Popen(
            shlex.split("st "+ "-f '{}:pixelsize={}' ".format(self.font, self.fsize) + \
                        "-c "+self.wim_name+" -e sh -c \"tmux -S "+self.tmux_sock_path+ \
                        " new -s nvim -n nvim nvim\""), stdout=subprocess.PIPE)

    def wim_run(self, file_args, mode="default"):
        if mode == "default":
            proc=self.process_list
        elif mode == "embedded":
            proc=self.eprocess_list

        if len(file_args):
            wid = subprocess.Popen(
                'xdotool search --classname {}'.format(self.wim_name).split(),
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT
            ).communicate()[0].decode("utf-8").strip('\n')

            if not len(wid):
                self.dprint("creating new {} server".format(self.wim_name))
                self.create_wim_server_from_scratch()
                proc(file_args)
            else:
                proc(file_args)
                pass

    def main(self, args):
        def socket_is_used_():
            return bool(list(filter(lambda i: i.laddr == self.tmux_sock_path, conns)) != [])

        def no_approp_win():
            ret_=True
            count_=(int(self.r.hmget('count_dict', 'wim')[0]))
            if count_ > 0:
                ret_=False
            return ret_

        try:
            conns=net_connections(kind='unix')
            # x11 window is closed, but tmux connection exists
            if socket_is_used_() and no_approp_win():
                self.dprint_with_args("Let's attach to existsing wim session", args)
                # do not wait for call result
                subprocess.Popen([
                    "st",
                    "-f", "{}:pixelsize={}".format(self.font, self.fsize),
                    "-c", "{}".format(self.wim_name),
                    "-e", "tmux", "-S", self.tmux_sock_path, "attach-session", "-d", "-t", "nvim"
                ])
            elif not socket_is_used_():
                self.dprint_with_args("Let's create tmux+nvim server from scratch", args)
                self.create_wim_server_from_scratch()
                self.V(args)
            elif len(args) > 0:
                self.dprint_with_args("Let's jump to target window", args)
                self.V(args)
        finally:
            self.socket_.close()

if __name__ == '__main__':
    run_=wim_runner()
    run_.main(argv)

# function wdiff {
#     local prev_
#     local arg2_
#     # or it's maybe better to use :windo diffthis
#     if [[ $# == 2 ]]; then
#         prev_="$1"
#         wim_run "" && v -b":tabnew" && \
#         { wim_run $1; shift } && v -b":diffthis" && \
#         { v -b":vs" && {
#             if [[ -d $1 ]]; then
#                 arg2_="$1/$(basename ${prev_})"
#             else
#                 arg2_="$1"
#             fi
#             wim_run ${arg2_};
#             shift
#         } && v -b":diffthis" }
#     fi
# }
