On May 30,  8:51am, Tim K. (Gmane) wrote:
}
} Is it possible to start zsh and invoke some other command/script but 
} upon command completion to return to interactive mode rather than exit 
} from zsh?

After the startup files are finished, zsh reads commands from exactly
one of four places:  The argument of the -c option, the current terminal,
the standard input, or a script file.

A script file is assumed if zsh has arguments but no options specifying
one of the other sources.  The documentation implies that -s forces zsh
to read from stdin, but in fact the -s option only determines whether
any further arguments are taken as the name of a script file; when both
-i and -s appear, -i takes precedence to force input from the terminal.
The -c option overrides both -i and -s, except that the .zshrc file is
read when both -i and -c appear.

The prompt is printed only in interactive mode, and you can't change the
value of that option after startup, so it's impossible to be prompted
after a command has been read from anywhere other than the terminal
(unless you run your own input loop e.g. using "vared").

} The only way I can think off is to put some hack in my .zshrc where if 
} some env variable is set it will run that command at the end of my 
} .zshrc file

How about using $@ instead of an environment variable?

    if [[ $1 == eval ]]
    then
      "$@"
  set --
    fi

Then you run this as

    zsh -is eval 'ls *.txt'

You could even skip the requirement that "eval" be the first word:

    if (( $# ))
    then
      eval "$@"
  set --
    fi

However, using "eval" as a keyword there means that you can still use
zsh -is with other argument strings without treating them as commands.

I like this because it lends itself to becoming an alias.

    alias zshi='zsh -is eval '

(The trailing space is for completion purposes.)

Hmm.  Depending on how you expect to use that, you might want to change
the .zshrc part to:

    if [[ $1 == eval ]]
    then
      "${(q)@}"
  set --
    fi

You can see the difference if you run:

    zshi echo foo \; echo bar
    zshi 'echo foo ; echo bar'

Try each of those both with the (q) and without, and pick the way that
makes the most sense to you.
